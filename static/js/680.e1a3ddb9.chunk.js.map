{"version":3,"file":"static/js/680.e1a3ddb9.chunk.js","mappings":"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","sources":["components/List.tsx","../node_modules/lodash-es/now.js","../node_modules/lodash-es/debounce.js","components/SearchBar.tsx","pages/Search.tsx"],"sourcesContent":["/** @jsxImportSource @emotion/react */\nimport { css } from \"@emotion/react\";\nimport { memo, useCallback } from \"react\"\nimport { usePostContext, Post } from \"../context/post\";\n\nconst gray = \"#e8e8e8\"\nconst grayDark = \"#8f8f8f\"\n\nconst row = css`\n  padding: 16px 0px;\n  border-bottom: 1px solid ${gray};\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  :hover {\n    .button-save {\n      display: block;\n    }\n    .save-tag {\n      display: none;\n    }\n  }\n`\n\nconst rowContent = css`\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n`\n\nconst saveButton = css`\n  text-align: right;\n  display: none;\n  background-color: white;\n  padding: 6px 8px;\n  font-size: 18px;\n  border-radius: 2px;\n  border: 1px solid black;\n  cursor: pointer;\n`\n\nconst rowDescription = css`\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  color: ${grayDark};\n  font-size: 16px;\n  font-weight: 500;\n`\n\nconst titleText = css`\n  font-size: 24px;\n  text-align: left;\n  margin-bottom: 8px;\n`\n\nconst authorNameText = css`\n  margin-right: 8px;\n`\n\nconst categoriesContainer = css`\n  display: flex;\n`\n\nconst categoryTag = css`\n  background-color: ${gray};\n  border-radius: 2px;\n  margin-left: 8px;\n  padding: 4px 6px;\n`\n\nconst savedTag = css`\n  background-color: ${grayDark};\n  color: white;\n  border-radius: 2px;\n  padding: 4px 6px;\n  :hover {\n    display: none;\n  }\n`\n\ninterface ListItemProps {\n  rowData: Post;\n  isFavorite?: boolean;\n}\n\nconst ListItem = (props: ListItemProps) => {\n  const { rowData } = props;\n  const { id, categories, title, author_name, isFavorite } = rowData\n  const { addFavorite, removeFavorite } = usePostContext();\n\n  const renderCategory = (category: string) => <div css={categoryTag}>{category}</div>\n\n  const handleClick = useCallback(() => {\n    if (isFavorite) {\n      removeFavorite(id);\n    } else {\n      addFavorite(rowData);\n    }\n  }, [id, isFavorite, rowData, addFavorite, removeFavorite])\n\n  return <div css={row}>\n    <div css={rowContent}>\n      <div css={titleText}>{title}</div>\n      <div css={rowDescription}>\n        <div css={authorNameText}>{author_name}</div>\n        <div css={categoriesContainer}>{categories.map(renderCategory)}</div>\n      </div>\n    </div>\n    <div>\n      {isFavorite && <div className=\"save-tag\" css={savedTag}>Saved</div>}\n      <button css={saveButton} className=\"button-save\" onClick={handleClick}>{isFavorite ? \"Unsave\" : \"Save\"}</button>\n    </div>\n  </div>\n}\n\ninterface Props {\n  list: Post[];\n}\nconst List = (props: Props) => {\n  const { list } = props;\n\n  return <div>\n    {list.map((rowData) => <ListItem rowData={rowData} />)}\n  </div>\n}\n\nexport default memo(List)\n","import root from './_root.js';\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nexport default now;\n","import isObject from './isObject.js';\nimport now from './now.js';\nimport toNumber from './toNumber.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nexport default debounce;\n","/** @jsxImportSource @emotion/react */\nimport { css } from \"@emotion/react\";\nimport { debounce } from \"lodash-es\";\nimport { memo, useCallback } from \"react\"\n\nconst gray = \"#e8e8e8\"\n\nconst container = css`\n  text-align: left;\n`\n\nconst search = css`\n  height: 35px;\n  width: 200px;\n  border: 1px solid ${gray};\n  border-radius: 1px;\n`\n\ninterface Props {\n  onSearch: (text: string) => void;\n  defaultValue?: string;\n}\n\nconst SearchBar = (props: Props) => {\n  const { onSearch, defaultValue } = props;\n  const debouncedChange = useCallback((event) => {\n    debounce((event) => {\n      onSearch((event.target as HTMLInputElement).value)\n    }, 1000)(event)\n  }, [onSearch]);\n  return <div css={container}>\n    <input defaultValue={defaultValue} css={search} type=\"search\" placeholder='Please enter the keyword' onChange={debouncedChange} />\n  </div>\n}\n\nexport default memo(SearchBar)","/** @jsxImportSource @emotion/react */\nimport { memo } from 'react';\nimport { css } from '@emotion/react'\nimport List from '../components/List';\nimport SearchBar from '../components/SearchBar';\nimport { usePostContext } from '../context/post';\n\nconst page = css`\n  padding: 16px;\n`\n\nconst empty = css`\n  margin-top: 32px;\n  text-align: left;\n  color: gray;\n`\n\nconst Search = () => {\n  const { post, handleSearch, keyword, viewState } = usePostContext();\n  return <div css={page}>\n    <SearchBar onSearch={handleSearch} defaultValue={keyword} />\n    {viewState === 'loading' && <div css={empty}>Loading...</div>}\n    {viewState === 'success' && (post.length === 0 ? <div css={empty}>No result</div> : <List list={post} />)}\n  </div>\n}\n\nexport default memo(Search)"],"names":["gray","grayDark","row","css","rowContent","saveButton","rowDescription","titleText","authorNameText","categoriesContainer","categoryTag","savedTag","ListItem","props","rowData","id","categories","title","author_name","isFavorite","usePostContext","addFavorite","removeFavorite","handleClick","useCallback","map","category","className","onClick","List","list","memo","root","nativeMax","Math","max","nativeMin","min","func","wait","options","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","undefined","apply","leadingEdge","setTimeout","timerExpired","shouldInvoke","timeSinceLastCall","now","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","arguments","this","clearTimeout","toNumber","isObject","cancel","flush","container","search","SearchBar","onSearch","defaultValue","debouncedChange","event","debounce","target","value","type","placeholder","onChange","page","empty","Search","post","handleSearch","keyword","viewState","length"],"sourceRoot":""}